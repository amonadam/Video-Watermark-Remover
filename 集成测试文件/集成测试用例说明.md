# 集成测试用例说明

## 概述

本文档详细说明了水印去除系统的集成测试用例设计，包括测试目标、测试场景、测试方法和预期结果。

## 测试目标

集成测试的主要目标是验证各个模块之间的接口交互是否正确，确保系统作为一个整体能够正常工作。具体目标包括：

1. **模块集成**: 验证核心模块（水印检测、修复、视频处理、安全控制）之间的正确集成
2. **数据流**: 确保数据在模块间正确传递和处理
3. **错误处理**: 验证错误在模块间的正确传播和处理
4. **安全性**: 验证访问控制和操作日志功能的集成
5. **端到端流程**: 验证从用户登录到视频处理的完整工作流程

## 测试架构

### 测试模块结构

```
集成测试文件/
├── test_integration.py          # 集成测试主文件
├── 集成测试结果报告.md           # 测试结果报告
├── 集成测试用例说明.md           # 本文档
└── GitHub_Issues_缺陷提交指南.md # 缺陷提交指南
```

### 测试类组织

集成测试按功能模块组织为以下测试类：

1. **TestWatermarkDetectorIntegration**: 水印检测器集成测试
2. **TestVideoProcessorIntegration**: 视频处理器集成测试
3. **TestSecurityIntegration**: 安全模块集成测试
4. **TestEndToEndIntegration**: 端到端集成测试
5. **TestErrorHandlingIntegration**: 错误处理集成测试
6. **TestPerformanceIntegration**: 性能集成测试

## 测试用例详解

### 1. TestWatermarkDetectorIntegration

#### 1.1 test_detector_inpainter_integration

**测试目标**: 验证水印检测器与修复器的协同工作

**测试步骤**:
1. 创建水印检测器实例
2. 创建LAMA修复器实例
3. 生成测试视频帧（带水印）
4. 使用检测器生成水印掩膜
5. 使用修复器修复水印区域
6. 验证修复结果

**预期结果**:
- 检测器能够正确生成水印掩膜
- 修复器能够正确修复水印区域
- 修复后的图像质量符合预期

**测试代码**:
```python
def test_detector_inpainter_integration(self):
    """测试水印检测器与修复器的集成"""
    detector = WatermarkDetector()
    inpainter = LamaInpainter()
    inpainter.use_cv2_fallback = True
    
    # 创建测试图像
    test_image = np.random.randint(0, 255, (1080, 1920, 3), dtype=np.uint8)
    
    # 生成水印掩膜
    mask = detector.generate_mask(test_image)
    
    # 修复水印
    if mask is not None:
        result = inpainter.inpaint(test_image, mask)
        assert result is not None
        assert result.shape == test_image.shape
```

### 2. TestVideoProcessorIntegration

#### 2.1 test_processor_detector_inpainter_integration

**测试目标**: 验证视频处理器与检测器、修复器的集成

**测试步骤**:
1. 创建视频处理器实例，配置检测器和修复器
2. 模拟视频文件
3. 执行视频处理流程
4. 验证处理结果

**预期结果**:
- 视频处理器能够正确调用检测器和修复器
- 处理后的视频不包含水印
- 处理统计信息正确

**测试代码**:
```python
@patch('core.video_processor.VideoFileClip')
@patch('core.video_processor.ImageSequenceClip')
def test_processor_detector_inpainter_integration(self, mock_imagesequence, mock_videoclip):
    """测试视频处理器与检测器、修复器的集成"""
    temp_dir = tempfile.mkdtemp()
    
    try:
        detector = WatermarkDetector()
        inpainter = LamaInpainter()
        inpainter.use_cv2_fallback = True
        config = {"auto_select_roi": True}
        
        video_path = os.path.join(temp_dir, "test.mp4")
        output_dir = os.path.join(temp_dir, "output")
        
        processor = VideoProcessor(video_path, output_dir, detector, inpainter, config)
        
        # 模拟视频剪辑对象
        mock_clip = Mock()
        mock_clip.w = 1920
        mock_clip.h = 1080
        mock_clip.duration = 10.0
        mock_clip.fps = 30.0
        mock_clip.get_frame = Mock(return_value=np.random.randint(0, 255, (1080, 1920, 3), dtype=np.uint8))
        mock_videoclip.return_value = mock_clip
        
        # 执行处理
        stats = processor.process()
        
        # 验证结果
        assert stats["success"] is True
        assert stats["processed_frames"] > 0
        
    finally:
        shutil.rmtree(temp_dir, ignore_errors=True)
```

#### 2.2 test_processor_color_correction_integration

**测试目标**: 验证颜色校正功能的集成

**测试步骤**:
1. 创建视频处理器实例，启用颜色校正
2. 处理测试视频
3. 验证颜色校正效果

**预期结果**:
- 颜色校正功能正常工作
- 修复后的图像颜色与周围区域一致

#### 2.3 test_full_processing_integration

**测试目标**: 验证完整的视频处理流程

**测试步骤**:
1. 创建完整的视频处理环境
2. 执行从水印检测到修复的完整流程
3. 验证每个步骤的结果

**预期结果**:
- 完整流程正常执行
- 每个步骤的输出符合预期

### 3. TestSecurityIntegration

#### 3.1 test_access_control_with_operation_logger

**测试目标**: 验证访问控制与操作日志的集成

**测试步骤**:
1. 初始化访问控制器
2. 注册测试用户
3. 初始化操作日志记录器
4. 用户登录
5. 记录用户操作
6. 查询操作日志

**预期结果**:
- 用户能够成功注册和登录
- 操作日志正确记录用户操作
- 能够查询到操作日志

**测试代码**:
```python
def test_access_control_with_operation_logger(self):
    """测试访问控制与操作日志的集成"""
    temp_dir = tempfile.mkdtemp()
    
    try:
        # 初始化访问控制
        db_path = os.path.join(temp_dir, "test_users.db")
        access_control = AccessController(user_db_path=db_path)
        
        # 注册测试用户
        access_control.add_user("testuser", "testpass", ["view", "edit"])
        
        # 初始化操作日志
        logger = OperationLogger(db_path)
        
        # 模拟用户登录
        user = access_control.authenticate("testuser", "testpass")
        assert user is not None
        
        # 设置当前用户
        set_current_user(user)
        
        # 记录操作
        logger.log_operation(
            username=user["username"],
            operation_type="test_operation",
            operation_result="success",
            ip_address="127.0.0.1",
            details="Integration test operation"
        )
        
        # 验证日志记录
        logs, _ = logger.get_operation_logs(username=user["username"])
        assert len(logs) > 0
        assert logs[0]["operation_type"] == "test_operation"
        
    finally:
        shutil.rmtree(temp_dir, ignore_errors=True)
```

#### 3.2 test_role_based_access_control_integration

**测试目标**: 验证基于角色的访问控制集成

**测试步骤**:
1. 注册管理员和普通用户
2. 分别以不同角色登录
3. 记录不同用户的操作
4. 验证权限控制

**预期结果**:
- 不同角色的用户能够正确登录
- 操作日志正确区分不同用户的操作
- 权限控制正常工作

### 4. TestEndToEndIntegration

#### 4.1 test_complete_workflow_integration

**测试目标**: 验证从用户登录到视频处理的完整工作流程

**测试步骤**:
1. 初始化安全模块
2. 用户登录
3. 初始化操作日志
4. 初始化视频处理模块
5. 记录操作开始
6. 执行视频处理
7. 记录操作结果
8. 验证端到端集成结果

**预期结果**:
- 完整工作流程正常执行
- 操作日志正确记录所有操作
- 视频处理结果符合预期

**测试代码**:
```python
@patch('core.video_processor.VideoFileClip')
@patch('core.video_processor.ImageSequenceClip')
@patch('os.makedirs')
@patch('os.path.exists')
def test_complete_workflow_integration(self, mock_exists, mock_makedirs, mock_imagesequence, mock_videoclip):
    """测试完整工作流程的端到端集成"""
    temp_dir = tempfile.mkdtemp()
    
    try:
        # 1. 初始化安全模块
        db_path = os.path.join(temp_dir, "test_users.db")
        access_control = AccessController(user_db_path=db_path)
        access_control.add_user("integrationuser", "testpass", ["view", "edit"])
        
        # 2. 用户登录
        user = access_control.authenticate("integrationuser", "testpass")
        assert user is not None
        
        # 设置当前用户
        set_current_user(user)
        
        # 3. 初始化操作日志
        logger = OperationLogger(db_path)
        
        # 4. 初始化视频处理模块
        detector = WatermarkDetector()
        inpainter = LamaInpainter()
        inpainter.use_cv2_fallback = True
        config = {
            "auto_select_roi": True,
            "margin": 50,
            "codec": "libx264",
            "bitrate": "5000k",
            "preset": "medium"
        }
        
        video_path = os.path.join(temp_dir, "test.mp4")
        output_dir = os.path.join(temp_dir, "output")
        
        processor = VideoProcessor(video_path, output_dir, detector, inpainter, config)
        
        # 5. 模拟文件存在
        mock_exists.return_value = True
        
        # 6. 模拟视频剪辑对象
        mock_clip = Mock()
        mock_clip.w = 1920
        mock_clip.h = 1080
        mock_clip.duration = 10.0
        mock_clip.fps = 30.0
        mock_clip.get_frame = Mock(return_value=np.random.randint(0, 255, (1080, 1920, 3), dtype=np.uint8))
        mock_videoclip.return_value = mock_clip
        
        # 7. 模拟水印掩膜
        watermark_mask = np.zeros((1080, 1920), dtype=np.uint8)
        watermark_mask[100:200, 100:200] = 255
        detector.generate_mask = Mock(return_value=watermark_mask)
        
        # 8. 模拟修复器
        inpainter.inpaint = Mock(return_value=np.random.randint(0, 255, (100, 100, 3), dtype=np.uint8))
        
        # 9. 模拟输出视频剪辑对象
        mock_output_clip = Mock()
        mock_output_clip.write_videofile = Mock()
        mock_imagesequence.return_value = mock_output_clip
        
        # 10. 记录操作开始
        logger.log_operation(
            username=user["username"],
            operation_type="video_processing_start",
            operation_result="started",
            ip_address="127.0.0.1",
            details=f"Video path: {video_path}"
        )
        
        # 11. 执行视频处理
        stats = processor.process()
        
        # 12. 记录操作结果
        logger.log_operation(
            username=user["username"],
            operation_type="video_processing_complete",
            operation_result="success" if stats["success"] else "failed",
            ip_address="127.0.0.1",
            details=f"Output: {stats.get('output_path')}, Time: {stats.get('processing_time')}, Frames: {stats.get('processed_frames')}"
        )
        
        # 13. 验证端到端集成结果
        assert stats["success"] is True
        assert stats["processed_frames"] > 0
        
        # 14. 验证操作日志
        logs, _ = logger.get_operation_logs(username=user["username"])
        assert len(logs) >= 2
        # 日志按时间倒序排列，最新的在前
        assert logs[0]["operation_type"] == "video_processing_complete"
        assert logs[1]["operation_type"] == "video_processing_start"
        
    finally:
        shutil.rmtree(temp_dir, ignore_errors=True)
```

### 5. TestErrorHandlingIntegration

#### 5.1 test_detector_failure_propagation

**测试目标**: 测试检测器失败时的错误传播

**测试步骤**:
1. 创建视频处理器实例
2. 模拟检测器失败
3. 执行视频处理
4. 验证错误处理

**预期结果**:
- 检测器失败时错误能够正确传播
- 系统能够优雅地处理错误
- 不会导致程序崩溃

#### 5.2 test_inpainter_failure_fallback

**测试目标**: 测试修复器失败时的降级处理

**测试步骤**:
1. 创建视频处理器实例
2. 模拟修复器失败
3. 验证降级处理机制

**预期结果**:
- 修复器失败时能够使用备用方案
- 降级处理不会影响整体功能

### 6. TestPerformanceIntegration

#### 6.1 test_large_video_processing_performance

**测试目标**: 测试大视频处理的性能

**测试步骤**:
1. 创建大尺寸测试视频
2. 执行视频处理
3. 测量处理时间
4. 验证性能指标

**预期结果**:
- 大视频能够在合理时间内处理完成
- 内存使用在合理范围内

#### 6.2 test_memory_usage_integration

**测试目标**: 测试内存使用情况

**测试步骤**:
1. 执行视频处理
2. 监控内存使用
3. 验证内存泄漏

**预期结果**:
- 内存使用在合理范围内
- 没有明显的内存泄漏

## 测试数据准备

### 测试视频

集成测试使用模拟视频数据，通过Mock对象模拟VideoFileClip和ImageSequenceClip的行为。

### 测试用户

集成测试使用临时数据库，每次测试创建独立的测试用户：

- **testuser**: 普通用户，权限：view, edit
- **testadmin**: 管理员用户，权限：view, edit, delete, admin
- **integrationuser**: 集成测试用户，权限：view, edit

### 测试配置

视频处理器配置：
```python
config = {
    "auto_select_roi": True,
    "margin": 50,
    "codec": "libx264",
    "bitrate": "5000k",
    "preset": "medium"
}
```

## 测试执行

### 运行所有集成测试

```bash
python -m pytest 集成测试文件/test_integration.py -v --tb=short
```

### 运行特定测试类

```bash
python -m pytest 集成测试文件/test_integration.py::TestSecurityIntegration -v
```

### 运行特定测试用例

```bash
python -m pytest 集成测试文件/test_integration.py::TestSecurityIntegration::test_access_control_with_operation_logger -v
```

### 生成覆盖率报告

```bash
python -m pytest 集成测试文件/test_integration.py --cov=src --cov-report=html
```

## 测试结果分析

### 通过标准

集成测试通过的标准：
1. 所有断言通过
2. 没有未捕获的异常
3. 测试执行时间在合理范围内
4. 内存使用正常

### 失败处理

如果集成测试失败，需要：
1. 分析失败原因
2. 检查模块接口是否正确
3. 验证数据流是否正确
4. 检查错误处理机制
5. 修复问题后重新测试

## 持续集成

集成测试应该集成到CI/CD流程中，每次代码提交后自动运行，确保系统集成的稳定性。

## 相关文档

- [集成测试结果报告](./集成测试结果报告.md)
- [GitHub Issues缺陷提交指南](./GitHub_Issues_缺陷提交指南.md)
- [单元测试结果报告](../单元测试文件/README.md)

---

**文档版本**: v1.0  
**最后更新**: 2026-01-05  
**维护者**: 测试团队
